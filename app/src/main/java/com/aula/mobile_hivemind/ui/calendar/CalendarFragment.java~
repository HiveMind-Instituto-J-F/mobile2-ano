package com.aula.mobile_hivemind.ui.calendar;

import android.content.res.Configuration;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.text.style.ForegroundColorSpan;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.constraintlayout.widget.ConstraintLayout;
import androidx.fragment.app.Fragment;
import androidx.recyclerview.widget.GridLayoutManager;
import androidx.recyclerview.widget.LinearLayoutManager;

import com.aula.mobile_hivemind.api.RetrofitClient;
import com.aula.mobile_hivemind.databinding.FragmentCalendarBinding;
import com.aula.mobile_hivemind.dto.RegistroParadaResponseDTO;
import com.aula.mobile_hivemind.recyclerViewParadas.Parada;
import com.aula.mobile_hivemind.recyclerViewParadas.ParadaCalendarAdapter;
import com.prolificinteractive.materialcalendarview.CalendarDay;
import com.prolificinteractive.materialcalendarview.DayViewDecorator;
import com.prolificinteractive.materialcalendarview.DayViewFacade;
import com.prolificinteractive.materialcalendarview.MaterialCalendarView;
import com.prolificinteractive.materialcalendarview.OnDateSelectedListener;
import com.prolificinteractive.materialcalendarview.format.ArrayWeekDayFormatter;
import com.prolificinteractive.materialcalendarview.format.MonthArrayTitleFormatter;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;

import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;

public class CalendarFragment extends Fragment {

    private FragmentCalendarBinding binding;
    private ParadaCalendarAdapter paradaCalendarAdapter;
    private List<Parada> todasParadas;
    private com.aula.mobile_hivemind.api.ApiMongoRegistroParadasService apiMongoService;
    private SimpleDateFormat dateFormat;

    @Override
    public View onCreateView(@NonNull LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {

        binding = FragmentCalendarBinding.inflate(inflater, container, false);
        View root = binding.getRoot();

        // Inicializar API MongoDB
        apiMongoService = RetrofitClient.getApiMongoRegistroService();
        dateFormat = new SimpleDateFormat("dd/MM/yyyy", Locale.getDefault());

        // Configurar layout responsivo
        configurarLayoutResponsivo();

        // Inicializar lista
        todasParadas = new ArrayList<>();

        // Configurar calendário
        configurarCalendario();

        // Configurar RecyclerView
        configurarRecyclerView();

        // Carregar paradas da API MongoDB
        carregarParadasDaApiMongo();

        return root;
    }

    private void configurarLayoutResponsivo() {
        boolean landscape = getResources().getConfiguration().orientation ==
                Configuration.ORIENTATION_LANDSCAPE;

        binding.recyclerViewCalendar.setLayoutManager(
                landscape ? new GridLayoutManager(getContext(), 1)
                        : new LinearLayoutManager(getContext())
        );

        if (landscape)
            binding.recyclerViewCalendar.setLayoutManager(new GridLayoutManager(getContext(), 2));
        else
            binding.recyclerViewCalendar.setLayoutManager(new LinearLayoutManager(getContext()));
    }


    private void configurarCalendario() {
        MaterialCalendarView calendarView = binding.calendarView;

        // Formato do título do mês em português
        calendarView.setTitleFormatter(new MonthArrayTitleFormatter(
                new String[]{"Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho",
                        "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"}
        ));

        // Formato dos dias da semana em português
        calendarView.setWeekDayFormatter(new ArrayWeekDayFormatter(
                new String[]{"Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"}
        ));

        // Remove setas de navegação
        calendarView.setLeftArrowMask(null);
        calendarView.setRightArrowMask(null);

        // Decora os dias do mês atual
        calendarView.addDecorator(new CurrentMonthDecorator());

        // Decoradores visuais para outros meses
        decorateOtherMonthDays(calendarView);

        // Listener de clique no calendário
        calendarView.setOnDateChangedListener(new OnDateSelectedListener() {
            @Override
            public void onDateSelected(@NonNull MaterialCalendarView widget, @NonNull CalendarDay date, boolean selected) {
                filtrarParadasPorData(date);
            }
        });
    }

    private void configurarRecyclerView() {
        // Configurar adapter
        paradaCalendarAdapter = new ParadaCalendarAdapter(getContext(), todasParadas);
        binding.recyclerViewCalendar.setAdapter(paradaCalendarAdapter);
    }

    private void carregarParadasDaApiMongo() {
        apiMongoService.getAllRegistros().enqueue(new Callback<List<RegistroParadaResponseDTO>>() {
            @Override
            public void onResponse(@NonNull Call<List<RegistroParadaResponseDTO>> call, @NonNull Response<List<RegistroParadaResponseDTO>> response) {
                if (response.isSuccessful() && response.body() != null) {
                    todasParadas.clear();
                    List<RegistroParadaResponseDTO> registros = response.body();

                    // Converter RegistroParadaResponseDTO para Parada
                    for (RegistroParadaResponseDTO registro : registros) {
                        Parada parada = converterParaParada(registro);
                        todasParadas.add(parada);
                    }

                    // Atualizar adapter e marcar datas no calendário
                    paradaCalendarAdapter.updateData(todasParadas);
                    marcarParadasNoCalendario(todasParadas);

                    // Mostrar mensagem se não houver paradas
                    if (todasParadas.isEmpty()) {
                        mostrarEstadoVazio("Nenhuma parada encontrada");
                    } else {
                        binding.recyclerViewCalendar.setVisibility(View.VISIBLE);
                        if (binding.textEmptyState != null) {
                            binding.textEmptyState.setVisibility(View.GONE);
                        }
                    }

                } else {
                    Toast.makeText(getContext(), "Erro ao carregar paradas: " + response.code(), Toast.LENGTH_SHORT).show();
                    mostrarEstadoVazio("Erro ao carregar paradas");
                }
            }

            @Override
            public void onFailure(@NonNull Call<List<RegistroParadaResponseDTO>> call, @NonNull Throwable t) {
                Toast.makeText(getContext(), "Falha na conexão: " + t.getMessage(), Toast.LENGTH_SHORT).show();
                mostrarEstadoVazio("Falha na conexão");
            }
        });
    }

    private void mostrarEstadoVazio(String mensagem) {
        binding.recyclerViewCalendar.setVisibility(View.GONE);
        if (binding.textEmptyState != null) {
            binding.textEmptyState.setText(mensagem);
            binding.textEmptyState.setVisibility(View.VISIBLE);
        }
    }

    private Parada converterParaParada(RegistroParadaResponseDTO registro) {
        Parada parada = new Parada();

        // Definir o ID do MongoDB
        parada.setId(registro.getId());

        // Definir dados básicos
        parada.setId_maquina(registro.getId_maquina());
        parada.setId_usuario(registro.getId_usuario());
        parada.setDes_setor(registro.getDes_setor());
        parada.setDes_parada(registro.getDes_parada());

        // Converter data e hora
        if (registro.getDt_parada() != null) {
            parada.setDt_parada(registro.getDt_parada());
        }

        if (registro.getHora_Inicio() != null) {
            parada.setHora_Inicio(registro.getHora_Inicio());
        }

        if (registro.getHora_Fim() != null) {
            parada.setHora_Fim(registro.getHora_Fim());
        }

        // Se houver ID de manutenção
        if (registro.getId_manutencao() != null) {
            parada.setId_manutencao(registro.getId_manutencao());
        }

        return parada;
    }

    private void decorateOtherMonthDays(MaterialCalendarView calendarView) {
        calendarView.addDecorator(new DayViewDecorator() {
            @Override
            public boolean shouldDecorate(CalendarDay day) {
                Calendar currentCalendar = Calendar.getInstance();
                Calendar dayCalendar = day.getCalendar();
                return dayCalendar.get(Calendar.MONTH) != currentCalendar.get(Calendar.MONTH) ||
                        dayCalendar.get(Calendar.YEAR) != currentCalendar.get(Calendar.YEAR);
            }

            @Override
            public void decorate(DayViewFacade view) {
                view.addSpan(new ForegroundColorSpan(Color.parseColor("#888888"))); // Cinza mais suave
            }
        });
    }

    private void marcarParadasNoCalendario(List<Parada> paradas) {
        Map<CalendarDay, Integer> mapaCores = new HashMap<>();

        for (Parada parada : paradas) {
            if (parada.getDt_parada() != null) {
                try {
                    Calendar calendar = Calendar.getInstance();
                    calendar.setTime(parada.getDt_parada());
                    CalendarDay dia = CalendarDay.from(calendar);

                    if (!mapaCores.containsKey(dia)) {
                        int cor = Color.parseColor("#1976D2"); // Azul Material Design
                        mapaCores.put(dia, cor);

                        // Adicionar decorador para esta data
                        List<CalendarDay> datas = new ArrayList<>();
                        datas.add(dia);
                        binding.calendarView.addDecorator(new EventoDecorador(datas, new ColorDrawable(cor)));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private void filtrarParadasPorData(CalendarDay dataSelecionada) {
        List<Parada> filtradas = new ArrayList<>();

        for (Parada parada : todasParadas) {
            if (parada.getDt_parada() != null) {
                Calendar calendar = Calendar.getInstance();
                calendar.setTime(parada.getDt_parada());

                if (calendar.get(Calendar.YEAR) == dataSelecionada.getYear() &&
                        calendar.get(Calendar.MONTH) == dataSelecionada.getMonth() &&
                        calendar.get(Calendar.DAY_OF_MONTH) == dataSelecionada.getDay()) {
                    filtradas.add(parada);
                }
            }
        }

        paradaCalendarAdapter.updateData(filtradas);

        // Mostrar/ocultar estado vazio
        if (filtradas.isEmpty()) {
            mostrarEstadoVazio("Nenhuma parada encontrada para esta data");
        } else {
            binding.recyclerViewCalendar.setVisibility(View.VISIBLE);
            if (binding.textEmptyState != null) {
                binding.textEmptyState.setVisibility(View.GONE);
            }
        }
    }

    // Decorador para o mês atual
    private class CurrentMonthDecorator implements DayViewDecorator {
        @Override
        public boolean shouldDecorate(CalendarDay day) {
            Calendar currentCalendar = Calendar.getInstance();
            Calendar dayCalendar = day.getCalendar();
            return dayCalendar.get(Calendar.MONTH) == currentCalendar.get(Calendar.MONTH) &&
                    dayCalendar.get(Calendar.YEAR) == currentCalendar.get(Calendar.YEAR);
        }

        @Override
        public void decorate(DayViewFacade view) {
            view.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
            view.addSpan(new ForegroundColorSpan(Color.parseColor("#212121"))); // Preto suave
        }
    }

    // Decorador para eventos
    private class EventoDecorador implements DayViewDecorator {
        private final List<CalendarDay> dates;
        private final Drawable drawable;

        public EventoDecorador(List<CalendarDay> dates, Drawable drawable) {
            this.dates = dates;
            this.drawable = drawable;
        }

        @Override
        public boolean shouldDecorate(CalendarDay day) {
            return dates.contains(day);
        }

        @Override
        public void decorate(DayViewFacade view) {
            view.setBackgroundDrawable(drawable);
            view.addSpan(new ForegroundColorSpan(Color.WHITE));
        }
    }

    @Override
    public void onConfigurationChanged(@NonNull Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        configurarLayoutResponsivo();
    }


    @Override
    public void onDestroyView() {
        super.onDestroyView();
        binding = null;
    }
}